"""
Helper functions for retrieving information.

Extra imports:
    requests
        https://pypi.org/project/requests/
    helpers
        https://github.com/grtakaha/protein_alignment_tool/blob/main/helpers.py

Functions:
    get_ftp(str, str, str) -> str or None
    verify_sprot()
    get_fasta(str) -> str
    blast(str, str, str, str)
    align(str, str, str, str)
    get_metadata(str) -> dict
"""

# time.sleep() pauses are placed in an attempt to comply with usage guidelines:
# https://blast.ncbi.nlm.nih.gov/doc/blast-help/developerinfo.html#rest
# https://ebi-biows.gitdocs.ebi.ac.uk/documentation/#fair-use-policy

# TODO: Consider condensing "ID"-type requests into one function.
# TODO: Fix potential endless loop if no exception is raised and status != 200.
# TODO: Make it so that non-UniProt entries don't run infinitely.

import os
import time
import sys
import subprocess
import shutil
import urllib
from contextlib import closing
import gzip
import requests
from helpers import find_path

def get_ftp(filename, out_dir, action="save"):
    """
    Retrieves a UniProt file with the given filename.

        Parameters:
            filename (str): A filename present in UniProt's
                            FTP server (ftp://ftp.uniprot.org), stored at:
                            /pub/databases/uniprot/current_release/knowledgebase/complete/
                            Ex. reldate.txt, README, uniprot_sprot.fasta.gz
            out_dir (str):  Directory for storage of retrieved file.
            action (str):   "save" or "read"
                            save - Saves retrieved file as [OUT_DIR]/[FILENAME].
                            read - Returns retrieved file as text.

        Returns:
            content (str): String of content from the given FTP request.

        Outputs:
            One directory (SwissProt) with the following files:
                README - Swiss-Prot README.
                reldate.txt - UniProt database release dates.
                uniprot_sprot.fasta.gz - Compressed Swiss-Prot database.
                uniprot_sprot.fasta - Decompressed Swiss-Prot database.
                uniprot_sprot.pdb, .phr, .pin, .pot, .psq, .ptf, .pto
                    - Files generated by makeblastdb.
    """

    # Base URL.
    url = "ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/"

    # Rerun the request until it returns 200.
    current_request = f"Retrieving {filename}"
    # Content will remain None if action != "read".
    content = None

    while True:
        try:
            # This does not check for status code.
            # See if Python3 urllib has a way to do this.
            with closing(urllib.request.urlopen(f"{url}/{filename}")) as response:
                print(f"{filename} found.\n", flush=True)
                if action == "save":
                    # Content is just saved at the specified location.
                    with open(f"{out_dir}/{filename}", 'wb') as ftp_file:
                        shutil.copyfileobj(response, ftp_file)
                elif action == "read":
                    # Content is decoded and read into content variable.
                    # Assume utf-8; response.headers.get_content_charset() returned None.
                    content = response.read().decode("utf-8")
                    print(content)
                break
        except urllib.error.URLError as urlerr:
            print(f"{current_request} caused a URL error: " +
                  f"{urlerr}. Exiting...\n", flush=True)
            sys.exit()

    # Will return either None or the content of the ftp request.
    return content

def check_blastdb(db):
    """
    Checks that a given BLAST database exists.
    Returns False if blastdbcmd returns "BLAST Database error".

        Parameters:
            db (str): The full file path to a possible BLAST database.

        Returns:
            blastdb_exists (str): True if blastdbcmd does not
                                  return an error using the input db.
    """

    print(f"Checking for BLAST database of {db}.\n",
          flush=True)
    blastdb_exists = True

    # Try to view BLAST db information using blastdbcmd.
    # If it raises an exception, then recreate database.
    try:
        subprocess.check_output(["blastdbcmd",
                        "-db", db,
                        "-info"])
        print(f"Valid BLAST database found for {db}.\n",
              flush=True)

    except subprocess.CalledProcessError as err:
        print(f"No valid BLAST database found for {db}.\n", 
              flush=True)
        blastdb_exists = False

    return blastdb_exists

def make_blastdb(db):
    """
    Creates a protein BLAST database from the given FASTA file.
    FASTA file MUST be protein sequences (not DNA or RNA).

        Parameters:
            db (str): The full file path to a protein FASTA file.

        Outputs:
            Files generated by makeblastdb:
                db.pdb, .phr, .pin, .pot, .psq, .ptf, .pto
    """
    # Title will be the file name.
    title = db.split("/")[-1]

    print(f"Creating BLAST database from {db}.\n",
          flush=True)
    subprocess.run(["makeblastdb",
                    "-in", db,
                    "-dbtype", "prot",
                    "-title", title], check=True)
    print(f"BLAST database created from {db}.\n",
          flush=True)

def verify_sprot():
    """
    Checks for the existence of and/or downloads Swiss-Prot files.

        Outputs:
            One directory (SwissProt) with the following files:
                README - Swiss-Prot README.
                reldate.txt - UniProt database release dates.
                uniprot_sprot.fasta.gz - Compressed Swiss-Prot database.
                uniprot_sprot.fasta - Decompressed Swiss-Prot database.
                uniprot_sprot.pdb, .phr, .pin, .pot, .psq, .ptf, .pto
                    - Files generated by makeblastdb.
    """

    sprot_path = find_path(f"{os.path.abspath(os.path.dirname(__file__))}/SwissProt/",
                           "w", "d")
    db = f"{sprot_path}/uniprot_sprot.fasta"
    
    sprot_exists = True
    current_reldate = get_ftp("reldate.txt", sprot_path, action="read")

    # Checks for .fasta, rather than .fasta.gz.
    # .fasta will be used for makeblastdb.
    if os.path.isfile(db):
        print("Swiss-Prot database found. Checking release...", flush=True)

        # Currently makes sure the entire file matches (not just Swiss-Prot).
        if os.path.isfile(f"{sprot_path}/reldate.txt"):
            with open(f"{sprot_path}/reldate.txt", "r", encoding="utf-8") as old_reldate:
                if old_reldate.read() == current_reldate:
                    print("Release dates are current.", flush=True)
                else:
                    print("Release dates are not current.\n",
                          flush=True)
                    sprot_exists = False
        else:
            print("No release dates found.\n",
                  flush=True)
            sprot_exists = False
    else:
        print("No Swiss-Prot database found.\n",
              flush=True)
        sprot_exists = False

    # Download and unpack Swiss-Prot files.
    if not sprot_exists:
        print("Downloading latest Swiss-Prot release.\n", flush=True)

        get_ftp("reldate.txt", sprot_path, action="save")
        get_ftp("README", sprot_path, action="save")
        get_ftp("uniprot_sprot.fasta.gz", sprot_path, action="save")

        # Immediately unpack uniprot_sprot.fasta.gz.
        with gzip.open(f"{db}.gz", 'rb') as sprot_gz:
            with open(db, "wb") as sprot_fasta:
                sprot_fasta.write(sprot_gz.read())

        print(f"Swiss-Prot files saved to: {sprot_path}", flush=True)

    print("Latest Swiss-Prot files successfully verified.\n", flush=True)

# TODO: Allow submission of a user-inputted database.
def blast(infile, stype, out_prefix, num_res="5", db=None):
    """
    BLASTs a given FASTA-formatted query against a local Swiss-Prot database.

        Parameters:
            infile (str):     FASTA query file.
            stype (str):      Sequence type.
                              "protein" for protein.
                              "dna" for nucleotide.
            out_prefix (str): Prefix for storage of output TSV.
                              Ex. [OUT_PREFIX].tsv
            num_res (str):    String integer of BLAST results to return.

        Outputs:
            BLAST results in outfmt 6 (TSV) form.

    """

    # If the user has not inputted their own database, use the downloaded Swiss-Prot db.
    if not db:
        sprot_path = find_path(f"{os.path.abspath(os.path.dirname(__file__))}/SwissProt/",
                               "w", "d")
        db = f"{sprot_path}/uniprot_sprot.fasta"

    title = db.split("/")[-1]

    # Variable stype is tied to program.
    if stype == "dna":
        program = "blastx"
    elif stype == "protein":
        program = "blastp"
    else:
        print("Given stype not found. Please specify " +
              "\"-stype dna\" for blastx OR \"-stype protein\" for blastp",
              flush=True)
        print("Defaulting to stype=\"protein\" and program=\"blastx\"\n",
              flush=True)
        stype = "protein"
        program = "blastp"

    print(f"BLASTing {infile} against {title} at {db}.\n",
          flush=True)
    # TODO: Unpack and submit all functional blastp options.
    # TODO: Consider adding back readable output.
    subprocess.run([program,
                    "-db", db,
                    "-query", infile,
                    "-outfmt", "6",
                    "-out", f"{out_prefix}.tsv",
                    "-num_alignments", num_res], check=True)

def get_fasta(fid):
    """
    Takes in a UniProt ID and returns that ID's FASTA-formatted sequence.

        Parameters:
            fid (str): A UniProt ID.

        Returns:
            response (str): A FASTA-formatted UniProt sequence.
    """

    url_fasta = f"https://rest.uniprot.org/uniprotkb/{fid}.fasta"

    # Rerun the request until it returns 200.
    current_request = "FASTA retrieval"
    while True:
        try:
            response = requests.get(url_fasta)
            if response.status_code != 200:
                print(f"{current_request} status code: " +
                      f"{response.status_code}. Retrying...\n", flush=True)
            else:
                break

        except requests.exceptions.ConnectionError as errc:
            print(f"{current_request} caused a connection error: " +
                  f"{errc}. Retrying...\n", flush=True)
        except requests.exceptions.RequestException as err:
            print(f"{current_request} caused exception: {err}. Exiting...\n",
                  flush=True)
            sys.exit()

        # If query fails, try again after 10 seconds.
        time.sleep(10)

    print(f"FASTA found for {fid}.\n", flush=True)

    return response.text

def align(infile, stype, out_directory, title):
    """
    Aligns given FASTA file using command-line Clustal Omega.

        Parameters:
            infile (str):        FASTA file with at least three sequences.
            stype (str):         Sequence type.
                                 "protein" for protein.
                                 "dna" for DNA.
            out_directory (str): Directory for storage of Clustal outputs.
            title (str):         A title for the output alignment.

        Outputs:
            An alignment (.clustal_num) and percent identity matrix (.pim)
            created from the input FASTA file.

    """

    print(f"Aligning {title}...\n", flush=True)
    stype_conv = {"protein":"Protein", "dna":"DNA", "rna":"RNA"}
    subprocess.run(["clustalo",
                    "--infile", infile,
                    "--outfile", f"{out_directory}/{title}.clustal",
                    "--seqtype", stype_conv[stype],
                    "--distmat-out", f"{out_directory}/{title}.pim",
                    "--percent-id", "--full",
                    "--outfmt", "clu", "--force"], check=True)

def get_metadata(mid):
    """
    Takes in a UniProt ID and returns that ID's JSON metadata.

        Parameters:
            mid (str): A UniProt ID.

        Returns:
            response (str): A JSON of the given ID's metadata.
    """

    # TODO: Consider returning only annotations.
    # Returns entire JSON.
    url_metadata = f"https://rest.uniprot.org/uniprotkb/{mid}"
    print(f"Retrieving metadata for {mid}.", flush=True)
    # Set headers to accept JSON.
    headers = {"Accept": "application/json"}

    # For this request specfically, terminate if the first request is not 200.
    # This is to avoid sending requests for non-UniProt accessions.
    current_request = "Metadata retrieval"
    while True:
        try:
            response_metadata = requests.get(url_metadata, headers)
            if response_metadata.status_code != 200:
                print(f"{current_request} status code: " +
                      f"{response_metadata.status_code}.\n" +
                      f"Failed to retrieve metadata for {mid}. Continuing...\n",
                      flush=True)
                return None # Handle Nonetype in script that calls this.
            else:
                break

        except requests.exceptions.ConnectionError as errc:
            print(f"{current_request} caused a connection error: " +
                  f"{errc}. Retrying...\n", flush=True)
        except requests.exceptions.RequestException as err:
            print(f"{current_request} caused exception: {err}. Exiting...\n",
                  flush=True)
            sys.exit()

        # If query fails, try again after 10 seconds.
        time.sleep(10)

    print(f"Metadata retrieved for {mid}.\n", flush=True)

    return response_metadata.json()
