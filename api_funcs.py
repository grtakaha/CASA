"""
Helper functions for retrieving information.

Extra imports:
    requests
        https://pypi.org/project/requests/
    helpers
        https://github.com/grtakaha/protein_alignment_tool/blob/main/helpers.py

Functions:
    get_ftp(str, str, str) -> str or None
    verify_sprot()
    get_fasta(str) -> str
    blast(str, str, str, str)
    align(str, str, str, str)
    get_metadata(str) -> dict
"""

# time.sleep() pauses are placed in an attempt to comply with usage guidelines:
# https://blast.ncbi.nlm.nih.gov/doc/blast-help/developerinfo.html#rest
# https://ebi-biows.gitdocs.ebi.ac.uk/documentation/#fair-use-policy

# TODO: Consider condensing "ID"-type requests into one function.
# TODO: Fix potential endless loop if no exception is raised and status != 200.
# TODO: Make it so that non-UniProt entries don't run infinitely.

import os
import time
import sys
import subprocess
import shutil
import urllib
from contextlib import closing
import gzip
import requests
from helpers import find_path, fasta_to_df

def get_ftp(filename, out_dir, action="save"):
    """
    Retrieves a UniProt file with the given filename.

        Parameters:
            filename (str): A filename present in UniProt's
                            FTP server (ftp://ftp.uniprot.org), stored at:
                            /pub/databases/uniprot/current_release/knowledgebase/complete/
                            Ex. reldate.txt, README, uniprot_sprot.fasta.gz
            out_dir (str):  Directory for storage of retrieved file.
            action (str):   "save" or "read"
                            save - Saves retrieved file as [OUT_DIR]/[FILENAME].
                            read - Returns retrieved file as text.

        Returns:
            content (str): String of content from the given FTP request.

        Outputs:
            One directory (SwissProt) with the following files:
                README - Swiss-Prot README.
                reldate.txt - UniProt database release dates.
                uniprot_sprot.fasta.gz - Compressed Swiss-Prot database.
                uniprot_sprot.fasta - Decompressed Swiss-Prot database.
                uniprot_sprot.pdb, .phr, .pin, .pot, .psq, .ptf, .pto
                    - Files generated by makeblastdb.
    """

    # Base URL.
    url = "ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/"

    # Rerun the request until it returns 200.
    current_request = f"Retrieving {filename}"
    # Content will remain None if action != "read".
    content = None

    while True:
        try:
            # This does not check for status code.
            # See if Python3 urllib has a way to do this.
            with closing(urllib.request.urlopen(f"{url}/{filename}")) as response:
                print(f"{filename} found.\n", flush=True)
                if action == "save":
                    # Content is just saved at the specified location.
                    with open(f"{out_dir}/{filename}", 'wb') as ftp_file:
                        shutil.copyfileobj(response, ftp_file)
                elif action == "read":
                    # Content is decoded and read into content variable.
                    # Assume utf-8; response.headers.get_content_charset() returned None.
                    content = response.read().decode("utf-8")
                    print(content)
                break
        except urllib.error.URLError as urlerr:
            print(f"{current_request} caused a URL error: " +
                  f"{urlerr}. Exiting...\n", flush=True)
            sys.exit()

    # Will return either None or the content of the ftp request.
    return content

def check_blastdb(db):
    """
    Checks that a given BLAST database exists.
    Returns False if blastdbcmd returns "BLAST Database error".

        Parameters:
            db (str): The full file path to a possible BLAST database.

        Returns:
            blastdb_exists (str): True if blastdbcmd does not
                                  return an error using the input db.
    """

    print(f"Checking for BLAST database of {db}.\n",
          flush=True)
    blastdb_exists = True

    # Try to view BLAST db information using blastdbcmd.
    # If it raises an exception, then recreate database.
    try:
        subprocess.check_output(["blastdbcmd",
                        "-db", db,
                        "-info"])
        print(f"Valid BLAST database found for {db}.\n",
              flush=True)

    except subprocess.CalledProcessError as err:
        print(f"No valid BLAST database found for {db}.\n", 
              flush=True)
        blastdb_exists = False

    return blastdb_exists

def make_blastdb(db):
    """
    Creates a protein BLAST database from the given FASTA file.
    FASTA file MUST be protein sequences (not DNA or RNA).

        Parameters:
            db (str): The full file path to a protein FASTA file.

        Outputs:
            Files generated by makeblastdb:
                db.pdb, .phr, .pin, .pot, .psq, .ptf, .pto
    """
    # Title will be the file name.
    title = db.split("/")[-1]

    print(f"Creating BLAST database from {db}.\n",
          flush=True)
    subprocess.run(["makeblastdb",
                    "-in", db,
                    "-dbtype", "prot",
                    "-title", title], check=True)
    print(f"BLAST database created from {db}.\n",
          flush=True)

def verify_sprot():
    """
    Checks for the existence of and/or downloads Swiss-Prot files.

        Outputs:
            One directory (SwissProt) with the following files:
                README - Swiss-Prot README.
                reldate.txt - UniProt database release dates.
                uniprot_sprot.fasta.gz - Compressed Swiss-Prot database.
                uniprot_sprot.fasta - Decompressed Swiss-Prot database.
                uniprot_sprot.pdb, .phr, .pin, .pot, .psq, .ptf, .pto
                    - Files generated by makeblastdb.
    """

    sprot_path = find_path(f"{os.path.abspath(os.path.dirname(__file__))}/SwissProt/",
                           "w", "d")
    db = f"{sprot_path}/uniprot_sprot.fasta"
    
    sprot_exists = True
    current_reldate = get_ftp("reldate.txt", sprot_path, action="read")

    # Checks for .fasta, rather than .fasta.gz.
    # .fasta will be used for makeblastdb.
    if os.path.isfile(db):
        print("Swiss-Prot database found. Checking release...", flush=True)

        # Currently makes sure the entire file matches (not just Swiss-Prot).
        if os.path.isfile(f"{sprot_path}/reldate.txt"):
            with open(f"{sprot_path}/reldate.txt", "r", encoding="utf-8") as old_reldate:
                if old_reldate.read() == current_reldate:
                    print("Release dates are current.", flush=True)
                else:
                    print("Release dates are not current.\n",
                          flush=True)
                    sprot_exists = False
        else:
            print("No release dates found.\n",
                  flush=True)
            sprot_exists = False
    else:
        print("No Swiss-Prot database found.\n",
              flush=True)
        sprot_exists = False

    # Download and unpack Swiss-Prot files.
    if not sprot_exists:
        print("Downloading latest Swiss-Prot release.\n", flush=True)

        get_ftp("reldate.txt", sprot_path, action="save")
        get_ftp("README", sprot_path, action="save")
        get_ftp("uniprot_sprot.fasta.gz", sprot_path, action="save")

        # Immediately unpack uniprot_sprot.fasta.gz.
        with gzip.open(f"{db}.gz", 'rb') as sprot_gz:
            with open(db, "wb") as sprot_fasta:
                sprot_fasta.write(sprot_gz.read())

        print(f"Swiss-Prot files saved to: {sprot_path}", flush=True)

    print("Latest Swiss-Prot files successfully verified.\n", flush=True)

def blast(infile, stype, out_prefix, num_res="5", db=None, **kwargs):
    """
    BLASTs a given FASTA-formatted query against a local Swiss-Prot database.

        Parameters:
            infile (str):     FASTA query file.
            stype (str):      Sequence type.
                              "protein" for protein.
                              "dna" for nucleotide.
            out_prefix (str): Prefix for storage of output TSV.
                              Ex. [OUT_PREFIX].tsv
            num_res (str):    String integer of BLAST results to return.

        Outputs:
            BLAST results in outfmt 6 (TSV) form.

    """
    
    print("Warning: If both -db [database] and -bopts \"-db [database]\"" +
          " were set, the -bopts database will be used.\n",
          flush=True)

    ## If the user has set db in kwargs, save here.
    #if kwargs.get("-db"):
        #db = kwargs.get("-db")

    #else:
        ## If the user has not inputted their own database, use Swiss-Prot.
        #if not db:
            ## Check for Swiss-Prot files in installation path.
            #verify_sprot()            
            #sprot_path = find_path(f"{os.path.abspath(os.path.dirname(__file__))}/SwissProt/",
                                   #"w", "d")
            #db = f"{sprot_path}/uniprot_sprot.fasta"

    ## If neither of the above are true, then use whatever was set as db.
    #db = find_path(db, "r", "f").replace("\\", "/")    

    #kwargs["-db"] = db

    # Check if a BLAST database exists for the given FASTA file.
    # Make BLAST database if one does not exist.
    if not check_blastdb(db):
        make_blastdb(db)

    #kwargs["-db"] = db

    print("Warning: If both -num_res [num_res] and -bopts" +
          " \"-num_alignments [num_res]\"" +
          " were set, the -bopts number of results (num_alignments)" +
          " will be used.\n",
          flush=True)

    # num_alignments overrides num_res
    if kwargs.get("-num_alignments"):
        num_res = kwargs.get("-num_alignments")
    else:
        kwargs["-num_alignments"] = num_res

    title = db.split("/")[-1]

    # Variable stype is tied to program.
    if stype == "dna":
        program = "blastx"
    elif stype == "protein":
        program = "blastp"
    else:
        print("Given stype not found. Please specify " +
              "\"-stype dna\" for blastx OR \"-stype protein\" for blastp",
              flush=True)
        print("Defaulting to stype=\"protein\" and program=\"blastx\"\n",
              flush=True)
        stype = "protein"
        program = "blastp"

    print(f"BLASTing {infile} against {title} at {db}.\n",
          flush=True)
    
    # TODO: Consider allowing modification of outfmt.
    # TODO: Consider adding back readable output.

    # I'll need to override query, outfmt, and out(?)
    # Everything else should be ok.
    print("Warning: \"-query\", \"-outfmt\", and \"-out\"" +
          " cannot be set by -bopts.\n",
          flush=True)
    
    kwargs["-query"] = infile
    kwargs["-outfmt"] = "6"
    kwargs["-out"] = f"{out_prefix}.tsv"

    # Add arguments to a list for submission to subprocces
    sub_args = [program]

    for key, value in kwargs.items():
        # This handles empty -bopts
        if key != "":
            sub_args.append(key)
        # This handles anything that doesn't require a value (like --force)
        if value != "":        
            sub_args.append(value)
    
    try:
        subprocess.run(sub_args, check=True)
    except subprocess.CalledProcessError as err:
        print("Call to blastp failed.\n" +
              "Please ensure that all arguments are valid blastp arguments.\n" +
              "Valid arguments can be shown via CLI with \"blastp -h\".\nExiting...",
              flush=True)
        exit()
        #raise subprocess.CalledProcessError

#def get_fasta(fid):
    #"""
    #Takes in a UniProt ID and returns that ID's FASTA-formatted sequence.

        #Parameters:
            #fid (str): A UniProt ID.

        #Returns:
            #response (str): A FASTA-formatted UniProt sequence.
    #"""

    #url_fasta = f"https://rest.uniprot.org/uniprotkb/{fid}.fasta"

    ## Rerun the request until it returns 200.
    #current_request = "FASTA retrieval"
    #while True:
        #try:
            #response = requests.get(url_fasta)
            #if response.status_code != 200:
                #print(f"{current_request} status code: " +
                      #f"{response.status_code}. Retrying...\n", flush=True)
            #else:
                #break

        #except requests.exceptions.ConnectionError as errc:
            #print(f"{current_request} caused a connection error: " +
                  #f"{errc}. Retrying...\n", flush=True)
        #except requests.exceptions.RequestException as err:
            #print(f"{current_request} caused exception: {err}. Exiting...\n",
                  #flush=True)
            #sys.exit()

        ## If query fails, try again after 10 seconds.
        #time.sleep(10)

    #print(f"FASTA found for {fid}.\n", flush=True)

    #return response.text

def get_fasta(fid, db_fasta):
    """
    Takes in a UniProt ID and returns that ID's FASTA-formatted sequence.

        Parameters:
            fid (str): A UniProt ID.

        Returns:
            response (str): A FASTA-formatted UniProt sequence.
    """

    current_request = "FASTA retrieval"

    try:
        #hit = db_fasta.loc[fid]
        acc = db_fasta.at[fid, "Accession"]
        seq = db_fasta.at[fid, "Sequence"]
        #acc = hit["Accession"]
        #seq = hit["Sequence"]
        print(f"FASTA found for {fid}.\n", flush=True)
    except KeyError as err:
        print(f"{current_request} caused exception: {err}.\n" +
              f"{fid} could not be found in {db}.\nExiting...\n",
              flush=True)
        sys.exit()

    return f"{acc}\n{seq}\n"

def align(infile, stype, out_directory, title, **kwargs):
    """
    Aligns given FASTA file using command-line Clustal Omega.

        Parameters:
            infile (str):        FASTA file with at least three sequences.
            stype (str):         Sequence type.
                                 "protein" for protein.
                                 "dna" for DNA.
            out_directory (str): Directory for storage of Clustal outputs.
            title (str):         A title for the output alignment.

        Outputs:
            An alignment (.clustal_num) and percent identity matrix (.pim)
            created from the input FASTA file.

    """

    print(f"Aligning...\n", flush=True)
    #print(f"Aligning {title}...\n", flush=True)
    #stype_conv = {"protein":"Protein", "dna":"DNA", "rna":"RNA"}
    #subprocess.run(["clustalo",
                    #"--infile", infile,
                    #"--outfile", f"{out_directory}/{title}.clustal",
                    #"--seqtype", stype_conv[stype],
                    #"--distmat-out", f"{out_directory}/{title}.pim",
                    #"--percent-id", "--full",
                    #"--outfmt", "clu", "--force"], check=True)
    

    print("Warning: Paths to any specified output files (like those " +
          "necessary for --distmat-out) will be overridden using " +
          "CASA's --out_directory option.\n",
          flush=True)

    # Override outputs for other files if they are provided
    # Delete (pop) alternative names for these options (like -l for log).
    if kwargs.get("--distmat-out"):
        kwargs["--distmat-out"] = f"{out_directory}/{title}.distmat"
    if kwargs.get("--guidetree-out"):
        kwargs["--guidetree-out"] = f"{out_directory}/{title}.guidetree"
    if kwargs.get("--clustering-out"):
        kwargs["--clustering-out"] = f"{out_directory}/{title}.clustering"
    if kwargs.get("--posterior-out"):
        kwargs["--posterior-out"] = f"{out_directory}/{title}.posterior"
    if kwargs.get("-l") or kwargs.get("--log"):
        kwargs.pop("-l", None)
        kwargs["--log"] = f"{out_directory}/{title}.log"

    # Override outputs for important options, regardless of if provided.
    # Delete (pop) alternative names for these options.
    kwargs.pop("-i", None)
    kwargs.pop("--in", None)    
    kwargs["--infile"] = infile
    kwargs.pop("-o", None)
    kwargs.pop("--out", None)
    kwargs["--outfile"] = f"{out_directory}/{title}.clustal"
    kwargs["--seqtype"] = stype
    kwargs["--force"] = ""
    kwargs["--outfmt"] = "clustal" # Always output clustal format

    # Add arguments to a list for submission to subprocces
    sub_args = ["clustalo"]
    for key, value in kwargs.items():
        # This handles empty -copts
        if key != "":
            sub_args.append(key)
        # This handles anything that doesn't require a value (like --force)
        if value != "":
            sub_args.append(value)

    try:
        subprocess.run(sub_args, check=True)
    except subprocess.CalledProcessError as err:
        print("Call to clustalo failed.\n" +
              "Please ensure that all arguments are valid clustalo arguments.\n" +
              "Valid arguments can be shown via CLI with \"custalo -h\".\nExiting...",
              flush=True)
        exit()    

def get_metadata(mid):
    """
    Takes in a UniProt ID and returns that ID's JSON metadata.

        Parameters:
            mid (str): A UniProt ID.

        Returns:
            response_metadata.json() (dict): A dictionary parsed
                                             from the response of
                                             a requests library request.
    """

    # TODO: Consider returning only annotations.
    # Returns entire JSON.
    url_metadata = f"https://rest.uniprot.org/uniprotkb/{mid}"
    #print(f"Retrieving metadata for {mid}.", flush=True)
    # Set headers to accept JSON.
    headers = {"Accept": "application/json"}

    # For this request specfically, terminate if the first request is not 200.
    # This is to avoid sending requests for non-UniProt accessions.
    current_request = "Metadata retrieval"
    while True:
        try:
            response_metadata = requests.get(url_metadata, headers)
            if response_metadata.status_code != 200:
                print(f"{current_request} status code: " +
                      f"{response_metadata.status_code}.\n" +
                      f"Failed to retrieve metadata for {mid}. Continuing...\n",
                      flush=True)
                return None # Handle Nonetype in script that calls this.
            else:
                break

        except requests.exceptions.ConnectionError as errc:
            print(f"{current_request} caused a connection error: " +
                  f"{errc}. Retrying...\n", flush=True)
        except requests.exceptions.RequestException as err:
            print(f"{current_request} caused exception: {err}. Exiting...\n",
                  flush=True)
            sys.exit()

        # If query fails, try again after 10 seconds.
        time.sleep(10)

    print(f"Metadata retrieved.", flush=True)

    # Returns a dictionary of the response
    return response_metadata.json()

def parse_json(json):
    """
    Takes a metadata JSON dictionary (returned by get_metadata(UniProt_ID)) and
    returns a tuple that includes:
        - A list of recommended EC numbers for this UniProt entry.
          Equivalent to Protein names > EC number on UniProt website.
        - This UniProt entry's recommended name as listed in UniProt.
          Equivalent to Protein names > Recommended name on UniProt website.

        Parameters:
            json (dict): A dictionary parsed
                         from the response of
                         a requests library request.

        Returns:
            (ec_nums, description) (list, str): A tuple of this UniProt entry's recommended
                                                EC numbers and name in UniProt.
    """    
    ec_nums = []
    description = ""
    pdb_ids = []

    json_description = json.get("proteinDescription")
    if json_description:
        rec_name = json_description.get("recommendedName")
    else:
        print(f"No values found under \"proteinDescription\".", flush=True)
        print(f"Proceeding with empty values.", flush=True)
        rec_name = None
    
    # This saves PDB IDs
    json_crossref = json.get("uniProtKBCrossReferences")
    if json_crossref:
        for crossref in json_crossref:
            database = crossref.get("database")
            data_id = crossref.get("id")
            if database == "PDB":
                if data_id:
                    pdb_ids.append(data_id) 
    else:
        print(f"No values found under \"uniProtKBCrossReferences\".", flush=True)
        print(f"Proceeding with empty values.", flush=True)   

    if rec_name:
        description = rec_name.get("fullName").get("value")
        # I don't think this will ever return None, but just in case.
        # Reset description to "".
        if not description:
            print("Description not found.", flush=True)
            description = ""
        else:
            print("Description found.", flush=True)

        ec_dicts = rec_name.get("ecNumbers")
        if ec_dicts:
            print("Recommended EC numbers found.", flush=True)
            for ec in ec_dicts:
                ec_nums.append(ec.get("value"))
        else:
            print("Recommended EC numbers not found.", flush=True)
    else:
        print(f"No values found under \"recommendedName\".", flush=True)
        print(f"Proceeding with empty values.", flush=True)

    return (ec_nums, description, pdb_ids)
